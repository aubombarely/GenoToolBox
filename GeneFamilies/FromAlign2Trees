#!/usr/bin/perl

=head1 NAME

 FromAlign2Trees
 Script to align multiple sequence files and run a ML tree 

=cut

our $VERSION = '0.1';
$VERSION = eval $VERSION;

=head1 SYPNOSIS

 FromAlign2Trees [-h] -i <fasta_file_list> -d <output_dir> -t <threads> [-s <seqtype>]
                      [-g <guidance_conf>] [-q <iqtree_conf>] [-o <outgroup_taxon>]
                      [-f <missing_taxa_cutoff_value>]
                      [-G] [-V] [-v] [-F]   

=head2 I<Flags:>

=over


=item -i

B<fasta_file_list>      File with two fields: CLID and fasta file path (mandatory)

=item -d

B<output_dir>           Name of the output directory (mandatory)

=item -t

B<threads>              Number of threads to be used by the Guidance and iQtree (default 2)

=item -s

B<seq_type>             Sequence type (options: DNA, CDS, PEP, default DNA)

=item -g

B<guidance_conf>        Guidance configuration file (optional)

=item -q

B<iqtree_conf>          iQtree configuration file (optional)

=item -o

B<outgroup_taxon>       outgroup taxon (optional)

=item -G

B<guidance_corrected>   use guidance corrected alignments (optional)

=item -F

B<filter_failed_taxa>   filter taxa that has not passed the iQtree check (optional)

=item -f

B<filter_aln_cutoff>    filter alignment with missing taxa ratio below this value (optional)

=item -V

B<be_verbose>           print more details of the running scripts

=item -v

B<version>              print script version

=item -h

B<help>                 Print the help

=back

=cut

=head1 DESCRIPTION

  This script run two programs Guidance and iQTree on a set of FASTA files with the
  goal of align the sequences and generate a phylogenetic tree.

  The script uses as an input a tabular file with two columns: cluster_id and file
  path to the fasta file.

  The script can use configuration files for Guidance and iQtree to pass specific
  arguments. The configuration file should have one argument per line with the 
  format -/--argument=value (e.g. --bootstraps=100). For switch arguments with no 
  values, the configuration file should have the word "ENABLED" (e.g. -wbt=ENABLED).

  The script also can use outgroup taxa. The outgroup taxa should be 4 or more 
  characters at the begining of each sequence ID. For example, if the sequences of
  the outgroup are Slyc000001 and Slyc000002, the output prefiix should be "Slyc".    

  Guidance produces several types of output. The ones that this script takes are:
   * MSA.<aligner>.aln.With_Names, a consensus alignment.
   * MSA.<aligner>.Without_low_SP_Col.With_Names, a edited alignment with conflictive
     nucleotides (or aminoacids) removed. This option is activated with the argument
     -G. If this option is activated, the formating step (2) will remove the taxa with
     only gaps.

  iQtree will be run twice. In the first run the best substitution model will be
  calculated. If there are some taxa that fail the iQtree taxa test, the can be 
  removed using the option -F. In the second run, the phylogentic tree will be estimated
  with the optimal model and a default boostrap of 100. The boostrat can be changed
  in the iQtree configuration file (-q <iqtree _conf>). 

=cut

=head1 AUTHORS

  Aureliano Bombarely.
  (aureliano.bombarely@unimi.it).

=cut


use strict;
use warnings;
use autodie;

use Getopt::Std;
use File::Spec;
use File::Basename;
use File::Copy;
use File::Path qw(make_path remove_tree);
use IPC::Cmd qw[can_run run];
use Math::BigFloat;
use Scalar::Util qw(looks_like_number);
use Bio::SeqIO;
use Bio::AlignIO;

our ($opt_i, $opt_d, $opt_s, $opt_t, $opt_g, $opt_q, $opt_o, $opt_G, $opt_f, $opt_F, $opt_V, $opt_v, $opt_h);
getopts("i:d:s:t:g:q:o:Gf:FVvh");

if (!$opt_i && !$opt_d && !$opt_s && !$opt_t && !$opt_g && !$opt_q && !$opt_o && !$opt_G && !$opt_f && !$opt_F && !$opt_V && !$opt_v && !$opt_h) {
    print "There are n\'t any tags. Print help\n\n";
    help();
}
elsif ($opt_v) {
    print STDERR "\nFromAlign2Trees version: $VERSION\n\n";
    exit(1);
}

my $date = `date`;
chomp($date);
print STDERR "\n\n############################################################";
print STDERR "\n## FromAlign2Trees Starts ($date)     ##\n";
print STDERR "############################################################\n\n";

## First will parse the equivalence file and store the sequences in a hash
## for a quick access.

#########################################################
## STEP 0: ARGUMENT CHECKS                             ##
#########################################################

print_header("Step 0 - Checking arguments");

## Check the input and parse the file paths
my $input = $opt_i;
my %fasta_list = ();
if (!$opt_i) {

    die("\nERROR: No -i <fasta_file_list> argument was supplied.\n");
}
else {

    my $l1 = 0;
    open my $ifh, '<', $input;
    while(<$ifh>) {
 
        chomp($_);
        $l1++;
        my @fields = split(/\t/, $_);
        if (scalar(@fields) != 2) {

            die("\nPARSING ERROR: Line $l1 at the file $input doesn't have two columns");
        }
        else {

            if (-e $fields[1]) {

                $fasta_list{$fields[0]} = $fields[1];
            }
            else {

                die("\nINPUT ERROR: file $fields[1] does not exist. Please check.\n");
            }
        }
    }
}

print STDERR "\tFASTA FILE LIST: $input\n";
my $list_n = scalar(keys %fasta_list);
print STDERR "\tFASTA FILE LIST has $list_n files.\n";

## Check the output dir
my $outdir = $opt_d;
if (!$opt_d) {

    die("\nERROR: No -d <outdir> argument was supplied.\n");
}
unless (-d $outdir) {

    die("\nERROR: -d <outdir> does not exist.\n");
}
print STDERR "\tOUTDIR: $outdir\n";

## Define the sequence type
my %allow_seqtypes = (
    "DNA" => 1,
    "CDS" => 2,
    "PEP" => 3
);

my $seqtype = $opt_s || "DNA";
unless (exists $allow_seqtypes{$seqtype}) {

    my $allows = join(",", sort keys %allow_seqtypes);
    die("\nERROR: -s <seqtype> does not have an allowed value ($allows).\n");
}
else {

    print STDERR "\tSEQTYPE: $seqtype\n";
}

## Check how many CPU(s) your system has
my $avail_cpus = `lscpu | grep "^CPU(s)"`;
chomp($avail_cpus);
$avail_cpus =~ s/CPU\(s\):\s+//;

my $threads = $opt_t || 2;
unless ($threads =~ m/^\d+$/) {

    die("ERROR: -t <threads> is not an integer.\n");
}
else {

    if ($threads > $avail_cpus) {

        die("\nERROR: -t <threads> $threads is bigger than the max. number of available threads on the system ($avail_cpus).\n");
    }
    print STDERR "\tTHREADS SET TO: $threads\n";
}

my $outgroup_taxa = "";
if ($opt_o) {

    $outgroup_taxa = $opt_o;
    print STDERR "\tTAXA OUTGROUP:\t$outgroup_taxa\n";
}
else {

    print STDERR "\tTAXA OUTGROUP:\tNone\n";
}


## Check the executables:
## It will wait until check the programs to check the freebayes arguments

my %exec_list = (
    GUIDANCE_PATH => ['guidance.pl'],
    IQTREE_PATH   => ['iqtree'],
    ); 

my %exepath = ();

foreach my $exec_key (sort keys %exec_list) {

    my @execitems = @{$exec_list{$exec_key}};
    foreach my $e_item (@execitems) {

        if (exists $ENV{$exec_key}) {
    
            $exepath{$e_item} = File::Spec->catfile($ENV{$exec_key}, $e_item);
            my $exe_path = can_run($exepath{$e_item});
            if ($exe_path) {

                print STDERR "\t$exec_key PATH defined for $e_item executable\n";
            }
            else {

	        die("\n\tERROR: The PATH $ENV{$exec_key} does not contain the $e_item executable.\n");
            }
        }
        else {
    
            my $exe_path = can_run($e_item);
            if ($exe_path) {
                
                $exepath{$e_item} = $exe_path;
                print STDERR "\t$e_item is available in the PATH ($exe_path)\n";
            }
            else {
                
                print STDERR "\nERROR: $e_item executable ($exec_key package)";
                die(" is not accessible.\n");
            }      
        }       
    }
}

## Get the permited options for Guidance

## There are some options that should not be used because it will 
## produce problems downstream to process the output

my %guidance_ban = (
    '--seqFile'      => 1,
    '--outDir'       => 1,
    '--proc_num'     => 1,
    '--msaFile'      => 1,
    '--Z_Seq_Cutoff' => 1,
    '--Z_Col_Cutoff' => 1,
    '--seqtype'      => 1
);

my %guidance_defaults = (
    '--msaProgram' => "MAFFT",
);

my %guidance_allowed = (
    '--msaProgram' => ["MAFFT", "PRANK", "CLUSTALW", "MUSCLE", "PAGAN"],
    '--program'    => ["GUIDANCE", "HoT", "GUIDANCE2"],
    '--bootstraps' => "integer",
    '--genCode'    => [1, 15, 6, 10, 2, 5, 3, 13, 9, 14, 4],
    '--outOrder'   => ["aligned", "as_input"], 
    '--seqCutoff'  => "0:1",
    '--colCutoff'  => "0:1",
    '--mafft'      => "path",
    '--prank'      => "path",
    '--clustalw'   => "path",
    '--muscle'     => "path",
    '--pagan'      => "path",
    '--ruby'       => "path",
    '--dataset'    => "string",
    '--MSA_Param'  => "string"
);

my %guidance_args = ();
if ($opt_g) {

    open my $gcf_fh, '<', $opt_g;
    while(<$gcf_fh>) {

        chomp($_);
        if ($_ !~ m/#/) {

            if ($_ =~ m/(--.+)\s*=\s*(.+)/) {

                if (exists $guidance_allowed{$1}) {

                    my $arg = $1;
                    my $val = $2;
                    if ($val =~ /^ENABLED$/i) {

                        $guidance_args{$arg} = "";
                    }
                    else {

                        $guidance_args{$arg} = $val;
                    }
                }
                elsif (exists $guidance_ban{$1}) {
 
                    die("\nARGUMENT BAN: $1 Guidance argument is reserved for this script. Delete from the config file\n");
                }
                else {

                    die("\nARGUMENT UNKNOWN: $1 argument is not a Guidance argument. Please modify accordingly.\n");
                }
            }
            else {

                die("\nPARSING ERROR: Guidance arguments at the configuration file should have the format --argument=value\n");
            }
        }
    }
}



print STDERR "\n\tGUIDANCE ARGUMENTS:\n";
if (scalar(keys %guidance_args) > 0) {

    foreach my $g_arg (sort keys %guidance_args) {

        print STDERR "\t\t$g_arg\t$guidance_args{$g_arg}\n";
    }
}
else {

    print STDERR "\t\tNONE, the program will use the default arguments.\n";
}

## Check and add the defaults

foreach my $gui_def (sort keys %guidance_defaults) {

    unless (exists $guidance_args{$gui_def}) {

        $guidance_args{$gui_def} = $guidance_defaults{$gui_def};
        print STDERR "\t\t\tArgument: $gui_def, default value: $guidance_defaults{$gui_def}\n";
    }
}


if ($opt_G) {

    print STDERR "\t\tGuidance alignment file to select: MSA.MAFFT.Without_low_SP_Col.With_Names\n";
}
else {

    print STDERR "\t\tGuidance alignment file to select: MSA.MAFFT.aln.With_Names\n";
}

my %iqtree_ban = (
    '-version'        => 1,
    '-s'              => 1,
    '-o'              => 1,
    '-pre'            => 1,
    '-nt'             => 1,
    '-ntmax'          => 1,
    '-redo'           => 1,
    '-cptime'         => 1,
    '--no-outfiles'   => 1,
    '-st'             => 1
);

my %iqtree_allowed = (
    '--msaProgram'    => ["MAFFT", "PRANK", "CLUSTALW", "MUSCLE", "PAGAN"],
    '-q'              => "partition_file",
    '-spp'            => "partition_file",
    '-sp'             => "partition_file",
    '-t'              => ["start_tree_file", "BIONJ", "RANDOM"],
    '-te'             => "user_tree_file",
    '-seed'           => "number",
    '-v'              => "verbose", 
    '-vv'             => "more verbose", 
    '-vvv'            => "top verbose",
    '-quiet'          => "quite mode",
    '-keep-ident'     => 1,
    '-safe'           => 1,
    '-mem'            => "number",
    '--runs'          => "number",
    '-lmap'           => "quartets",
    '-lmclust'        => "clustfile",
    '-wql'            => 1, 
    '-ninit'          => "number",
    '-ntop'           => "number",
    '-nbest'          => "number",
    '-n'              => "iterations",
    '-nstop'          => "number",
    '-pers'           => "proportion",
    '-sprrad'         => "number",
    '-allnni'         => 1,
    '-g'              => "constraint_tree",
    '-fast'           => 1,
    '-bb'             => "replicates",
    '-bsam'           => ["GENE", "GENESITE"],
    '-wbt'            => 1,
    '-wbtl'           => 1,
    '-nm'             => "iterations",
    '-nstep'          => "iterations",
    '-bcor'           => "min_corr",
    '-beps'           => "epsilon",
    '-bnni'           => 1,
    '-j'              => "jackknife",
    '-b'              => "replicates",
    '-bc'             => "replicates",
    '-bo'             => "replicates", 
    '-alrt'           => "replicates",
    '-abayes'         => 1,
    '-lbp'            => "replicates",  
    '-m'              => [" TESTONLY", "TEST","MF", "MFP", "TESTMERGEONLY", "TESTMERGE", "MF+MERGE", "MFP+MERGE"],
    '-rcluster'       => "percent",
    '-rclusterf'      => "percent",
    '-rcluster-max'   => "number",
    '-mset'           => ["raxml", "phyml", "mrbayes", "liemarkov", "liemarkovry", "liemarkovws", "liemarkovmk", "strandsymmetric"],
    '-msub'           => ["nuclear", "mitochondrial", "chloroplast", "viral"],
    '-mfreq'          => "state frequencies",
    '-mrate'          => "rate-across-sties models",
    '-cmin'           => "kmin",
    '-cmax'           => "kmax",
    '-merit'          => ["AIC", "AICc", "BIC"],
    '-mtree'          => 1,
    '-mredo'          => 1,
    '-madd'           => "mixture models",
    '-mdef'           => "nexus_file",
    '-m'              => "model_name",
    '-mwopt'          => 1,
    '-a'              => "Gamma_shape",
    '-amin'           => "min_shape",
    '-gmedian'        => 1,
    '--opt-gamma-inv' => 1,
    '-i'              => "p_invar", 
    '-wsr'            => 1,
    '-mh'             => 1,
    '-s'              => "counts_file",
    '-nni-eval'       => "number",
    '-ft'             => "tree_file",
    '-fs'             => "in_freq_file",
    '-fmax'           => 1,
    '-t'              => "tree_file",
    '-minsup'         => "threshold",
    '-bi'             => "burnin",
    '-con'            => 1,
    '-net'            => 1,
    '-sup'            => "target_tree",
    '-suptag'         => "name",
    '-rf_all'         => 1,
    '-rf'             => "treefile2",
    '-rf_adj'          => 1,
    '-z'              => "trees_file",
    '-zb'             => "replicates",
    '-zw'             => 1,
    '-au'             => 1,
    '-asr'            => 1,
    '-asr-min'        => "probability",
    '-r'              => "num_taxa",
    '-ru'             => "num_taxa",
    '-rcat'           => "num_taxa",
    '-rbal'           => "num_taxa",
    '-rcsg'           => "num_taxa",
    '-rlen'           => ["min_len", "mean_len", "max_len"],
    '-wt'             => 1,
    '-blfix'          => 1,
    '-blscale'        => 1,
    '-blmin'          => "numeric",
    '-blmax'          => "numeric", 
    '-wsr'            => 1,
    '-wsl'            => 1,
    '-wslr'           => 1,
    '-wslm'           => 1,
    '-wslmr'          => 1,
    '-wspr'           => 1,
    '-wspm'           => 1,
    '-wspmr'          => 1,
    '-wpl'            => 1,
    '-fconst'         => "constant_patterns",
    '-me'             => "epsilon",      
    '--eigenlib'      => 1,
    '-alninfo'        => 1,
    '-czb'            => 1,
    '--show-lh'       => 1
);

my %iqtree_args = ();
if ($opt_q) {

    open my $qcf_fh, '<', $opt_q;
    while(<$qcf_fh>) {

        chomp($_);
        if ($_ !~ m/#/) {

            if ($_ =~ m/(-.+)\s*=\s*(.+)/) {

                if (exists $iqtree_allowed{$1}) {

                    my $arg = $1;
                    my $val = $2;
                    if ($val =~ /^ENABLED$/i) {

                        $iqtree_args{$arg} = "";
                    }
                    else {

                        $iqtree_args{$arg} = $val;
                    }
                }
                elsif (exists $iqtree_ban{$1}) {
 
                    die("\nARGUMENT BAN: $1 iQtree argument is reserved for this script. Delete from the config file\n");
                }
                else {

                    die("\nARGUMENT UNKNOWN: $1 argument is not a iQtree argument. Please modify accordingly.\n");
                }
            }
            else {

                die("\nPARSING ERROR: iQtree arguments at the configuration file should have the format -/--argument=value\n");
            }
        }
    }
}

print STDERR "\n\tiQTree ARGUMENTS:\n";
if (scalar(keys %iqtree_args) > 0) {

    foreach my $q_arg (sort keys %iqtree_args) {

        print STDERR "\t\t$q_arg\t$iqtree_args{$q_arg}\n";
    }
}
else {

    print STDERR "\t\tNONE, the program will use the default arguments.\n";
}

## Add the seqtype to Guidance and iQtree

## Filter option

if ($opt_F) {

    print STDERR "\tALIGNMENT FILTERING AFTER IQTREE MODEL: On\n";
}
else {

    print STDERR "\tALIGNMENT FILTERING AFTER IQTREE MODEL: Off\n";
}

my $filter_missing_taxa = 1;
if ($opt_f) {

    unless (looks_like_number($opt_f)) {

        die("\nERROR: -f <missing_taxa_ratio> doesn't have a numeric value.\n");
    }
    else {
        if ($opt_f > 1 || $opt_f < 0) {

            die("\nERROR: -f <missing_taxa_ratio> does not a value between 0 and 1.\n");
        }
        else {

            $filter_missing_taxa = $opt_f;
            print STDERR "\tFILTER MISSING DATA: $filter_missing_taxa\n";
        }
    }
}
else {

    print STDERR "\tFILTER MISSING DATA: disabled.\n";
}


if ($seqtype eq "DNA") {

    $guidance_args{'--seqtype'} = "nuc";
    $iqtree_args{'-st'} = "DNA";
}
elsif ($seqtype eq "CDS") {

    $guidance_args{'--seqtype'} = "codon";
    $iqtree_args{'-st'} = "CODON";
}
elsif ($seqtype eq "PEP") {

    $guidance_args{'--seqtype'} = "aa";
    $iqtree_args{'-st'} = "AA";
}



#########################################################
## STEP 1: RUN GUIDANCE                                ##
#########################################################
##
## The basic guidance command is something like:
## guidance.pl --seqFile <myfile.fasta> --msaProgram MAFFT --seqType aa --outDir <myfile_guidance> --proc_num <threads>

## It will store the output files in a hash

print_header("Step 1 - Running Guidance");

my %guidance_dirs = ();

## First, create a directory for the guidance outputs
my $dir01_guidance = File::Spec->catfile($outdir, "01_GuidanceOut");
my $log01_guidance = File::Spec->catfile($outdir, "run01_guidance.log");

if (-d $dir01_guidance) {

    opendir( my $dir01_fh, $dir01_guidance);
    while(readdir $dir01_fh) {

        my $subdir01 = File::Spec->catfile($dir01_guidance, $_);
        my $subdir01_abs = File::Spec->rel2abs($subdir01);    
        if ($_ =~ m/(.+)_GuidanceAlign/) {

            my $gid = $1;
            $guidance_dirs{$gid} = $subdir01_abs;
        }
    }
    closedir($dir01_fh);

    print STDERR "\tGuidance directory detected.\n";
    my $gui_files_n = scalar(keys %guidance_dirs);

    if ($gui_files_n > 0) {

        print STDERR "\t$gui_files_n files have been added to the pipeline.\n";
    }
    else {

        die("\nERROR: No Guidance files were detected inside $dir01_guidance.\n\tPlease delete the directory and rerun the script.\n");
    }
}
else {

    mkdir($dir01_guidance);
}

## WARNING: Guidance requires from the absolute path for the
## output files.

if (scalar(keys %guidance_dirs > 0)) {

    print STDERR "\n\tGuidance files were detected. Skipping step.\n";

} 
else {

    my $dir01_guidance_abs = File::Spec->rel2abs($dir01_guidance);

    open my $gui_log_fh, '>', $log01_guidance;

    my ($guid_runs, $guid_ok, $guid_fails) = (0, 0, 0);

    foreach my $gid (sort keys %fasta_list) {

        my $clid_guidance_out = File::Spec->catfile($dir01_guidance_abs, $gid . "_GuidanceAlign");	

        my @guidance_cmd = ($exepath{'guidance.pl'}, "--seqFile", $fasta_list{$gid}, "--outDir", $clid_guidance_out);
        push(@guidance_cmd, ("--proc_num", $threads));

        foreach my $guidance_arg (sort keys %guidance_args) {

            push @guidance_cmd, $guidance_arg;  
            if ($guidance_args{$guidance_arg} =~ m/.+/) {
    
                push @guidance_cmd, $guidance_args{$guidance_arg};
            }
        }
    
        print $gui_log_fh "RUN\tGUIDANCE\t$gid\tSTART\n";
        my $guidance_cmd = join(" ", @guidance_cmd);
        print $gui_log_fh "CMD $guidance_cmd\n";

        $guid_runs++;
        my @guidance01run = run( command => \@guidance_cmd, verbose => $opt_V );
        if ($guidance01run[1]) {

            print $gui_log_fh "RUN\tGUIDANCE\t$gid\tFAIL\n";
            print $gui_log_fh "GUIDANCE ERROR: $guidance01run[1]\n$guidance01run[4]\n\n";
            $guid_fails++;
        }
        else {

            print $gui_log_fh "RUN\tGUIDANCE\t$gid\tFINISHED\n";
            print $gui_log_fh "GUIDANCE EXECUTION MESSAGE: $guidance01run[0]\n\n";
            $guidance_dirs{$gid} = $clid_guidance_out;
            $guid_ok++;
        }
    }

    print STDERR "\tGuidance runs finished\n";
    print STDERR "\t\t$guid_runs processes have been run of which $guid_fails failed and $guid_ok succeed\n";
}

#########################################################
## STEP 2: CHANGE FORMATS                              ##
#########################################################

## Guidance produces the alignment with some in house names
## Additionally, iQtree requires phylip format instead fasta
## so this step will perform both tasks

print_header("Step 2 - Formatting Guidance alignments");

my %guiform_dirs = ();

## First, create a directory for the guidance outputs
my $dir02_guiform = File::Spec->catfile($outdir, "02_GuidanceFormatted");
my $log02_guiform = File::Spec->catfile($outdir, "run02_guidance_formatting.log");

if (-d $dir02_guiform) {

    opendir( my $dir02_fh, $dir02_guiform);
    while(readdir $dir02_fh) {

        my $subdir02 = File::Spec->catfile($dir02_guiform, $_);
        my $subdir02_abs = File::Spec->rel2abs($subdir02);
        if ($_ =~ m/(.+).guidance_aln.phy/) {

            my $gid = $1;
            $guiform_dirs{$gid} = $subdir02_abs;
        }
    }
    closedir($dir02_fh);

    print STDERR "\tGuidance formatting directory detected.\n";
    my $guif_files_n = scalar(keys %guiform_dirs);

    if ($guif_files_n > 0) {

        print STDERR "\t$guif_files_n files have been added to the pipeline.\n";
    }
    else {

        die("\nERROR: No Guidance formatted files were detected inside $dir02_guiform.\n\tPlease delete the directory and rerun the script.\n");
    }
}
else {

    mkdir($dir02_guiform);
}

if (scalar(keys %guiform_dirs > 0)) {

    print STDERR "\n\tGuidance formatted files were detected. Skipping step.\n";

}
else {

    open my $guif_log_fh, '>', $log02_guiform;

    ## Now it will go file by file and change format from fasta msa to phylip
    
    foreach my $gid (sort keys %guidance_dirs) {

        my $align_file = "MSA.MAFFT.aln.With_Names";
        if ($opt_G) {

  	    $align_file = "MSA.MAFFT.Without_low_SP_Col.With_Names"; 
        }

        my $target_file = File::Spec->catfile($guidance_dirs{$gid}, $align_file);
        my $out_file = File::Spec->catfile($dir02_guiform, $gid .".guidance_aln.phy");
        my $equiv_file = File::Spec->catfile($dir02_guiform, $gid .".guidance.id_equivalence.txt");
        open my $eqfh, '>', $equiv_file;

        my $seqn = 0;
        
        my $old_align_obj = Bio::AlignIO->new(-file   => $target_file,
                                              -format => 'fasta');

        my $new_align_obj = Bio::AlignIO->new(-file   => ">$out_file" ,
                                              -format => 'phylip');
 
        while ( my $aln = $old_align_obj->next_aln() ) {
        
            foreach my $seqobj ($aln->each_seq) {
    
                my $seqid = $seqobj->id();
                my $seqlength = $seqobj->length();
                my $nogaps = $seqobj->seq();
                $nogaps =~ s/-//g;
                
                my $nogaps_length = length($nogaps);

                if ($nogaps_length > 0) {

                    if (length($seqid) > 10) { 
  
                        $seqn++;
                        my @break_id = split(//, $seqid);
                        my $prefix = join("", @break_id[0..4]);
                        my $newid = $prefix.sprintf("%05s", $seqn);
                        print $eqfh "$seqid\t$seqid\n";
                        $seqobj->id($newid);
                    }
		    else {

                        print $eqfh "$seqid\t$seqid\n";
                    }
                }
                else {
        
                    print STDERR "\nWarning: $seqid has not nucleotides from $gid. Removing from alignment.\n";
                    $aln->remove_seq($seqobj);
                }
            }

            $new_align_obj->write_aln($aln);
        }

        $guiform_dirs{$gid} = $out_file;
    }

    my $phylip_n = scalar(keys %guiform_dirs);
    print STDERR "\n\t$phylip_n files have been converted to phylip format.\n";
}

#########################################################
## STEP 3: RUN IQTREE                                  ##
#########################################################

## Once Guidance runs, the script will select the alignment
## files and run iqTree

print_header("Step 3 - Run iQtrees - Optimize the model");

my %iqtreemodel_dirs = ();

## First, create a directory for the guidance outputs
my $dir03_iqtreem = File::Spec->catfile($outdir, "03_iQtreeModel");
my $log03_iqtreem = File::Spec->catfile($outdir, "run03_iQtreeModel.log");

if (-d $dir03_iqtreem) {

    opendir( my $dir03_fh, $dir03_iqtreem);
    while(readdir $dir03_fh) {

        my $subdir03 = File::Spec->catfile($dir03_iqtreem, $_);
        my $subdir03_abs = File::Spec->rel2abs($subdir03);
        if ($_ =~ m/(.+)_iQtreeModels/) {

            my $gid = $1;
            my $clid_iqtreem_pre = File::Spec->catfile($subdir03_abs, $gid . "_iqtree_models");
            $iqtreemodel_dirs{$gid} = $clid_iqtreem_pre;
        }
    }
    closedir($dir03_fh);

    print STDERR "\tiQtree model directory detected.\n";
    my $iqtreem_files_n = scalar(keys %iqtreemodel_dirs);

    if ($iqtreem_files_n > 0) {

        print STDERR "\t$iqtreem_files_n files have been added to the pipeline.\n";
    }
    else {

        die("\nERROR: No iQTree files were detected inside $dir03_iqtreem.\n\tPlease delete the directory and rerun the script.\n");
    }
}
else {

    mkdir($dir03_iqtreem);
}

if (scalar(keys %iqtreemodel_dirs > 0)) {

    print STDERR "\n\tiQtree models files were detected. Skipping step.\n";

}
else {

    my $dir03_iqtreem_abs = File::Spec->rel2abs($dir03_iqtreem);

    open my $iqtreem_log_fh, '>', $log03_iqtreem;

    my ($iqtreem_runs, $iqtreem_ok, $iqtreem_fails) = (0, 0, 0);

    foreach my $gid (sort keys %guiform_dirs) { 

        my $clid_iqtreem_out = File::Spec->catfile($dir03_iqtreem_abs, $gid . "_iQtreeModels");
        mkdir($clid_iqtreem_out);
        my $clid_iqtreem_pre = File::Spec->catfile($clid_iqtreem_out, $gid . "_iqtree_models");

        my @iqtreem_cmd = ($exepath{'iqtree'}, "-s", $guiform_dirs{$gid}, "-pre", $clid_iqtreem_pre);
        push(@iqtreem_cmd, ("-nt", $threads));

        foreach my $iqtree_arg (sort keys %iqtree_args) {

            push @iqtreem_cmd, $iqtree_arg;
            if ($iqtree_args{$iqtree_arg} =~ m/.+/) {

                push @iqtreem_cmd, $iqtree_args{$iqtree_arg};
            }
        }

        print $iqtreem_log_fh "RUN\tIQTREE (MODEL)\t$gid\tSTART\n";
        my $iqtreem_cmd = join(" ", @iqtreem_cmd);
        print $iqtreem_log_fh "CMD $iqtreem_cmd\n";

        $iqtreem_runs++;
        my @iqtreem02run = run( command => \@iqtreem_cmd, verbose => $opt_V );
        if ($iqtreem02run[1]) {

            print $iqtreem_log_fh "RUN\tIQTREE (MODEL)\t$gid\tFAIL\n";
            print $iqtreem_log_fh "IQTREE ERROR: $iqtreem02run[1]\n";
            foreach my $err (@{$iqtreem02run[4]}) {
   
                print $iqtreem_log_fh "ERROR BACKTRACE: $err\n";
            }
            print $iqtreem_log_fh "\n";
            $iqtreem_fails++;
        }
        else {

            print $iqtreem_log_fh "RUN\tIQTREE (MODEL)\t$gid\tFINISHED\n";
            print $iqtreem_log_fh "IQTREE (MODEL) EXECUTION MESSAGE: $iqtreem02run[0]\n\n";
            $iqtreemodel_dirs{$gid} = $clid_iqtreem_pre;
            $iqtreem_ok++;
        }
    }

    print STDERR "\tiQtree (model) runs finished\n";
    print STDERR "\t\t$iqtreem_runs processes have been run of which $iqtreem_fails failed and $iqtreem_ok succeed\n";
}

print STDERR "\n\tExtracting Best model information and the taxa check information\n";

my %parsed_iqtreem = ();
my %testtax_iqtreem = ();
foreach my $clid (sort keys %iqtreemodel_dirs) {

    my $iqtree_info_href = parse_iqtree_file($iqtreemodel_dirs{$clid}.".iqtree");
    $parsed_iqtreem{$clid} = $iqtree_info_href;
    my $best_model = $iqtree_info_href->{"BestFitModel"};
    $parsed_iqtreem{$clid} = $best_model;

    my $iqtree_log_hashref = parse_iqtree_log($iqtreemodel_dirs{$clid}.".log");
    my %iqtree_log = %{$iqtree_log_hashref};
    my ($taxa, $non_passed) = (0, 0);
    $testtax_iqtreem{$clid} = $iqtree_log_hashref;
    foreach my $taxid (sort keys %iqtree_log) {

        $taxa++;
        if ($iqtree_log{$taxid}->{"test_result"} eq "failed") {

            $non_passed++;
        }
    }
    print STDERR "\t\t$clid\t$best_model\tNon Passed Taxa: $non_passed of $taxa\n";
} 

#########################################################
## STEP 4: FILTER ALIGNMENTS                           ##
#########################################################

## iQTree gave some information about the alignments.
## The script will filter those taxa that are not okay.
## It will also filter out alignments without outgroup
## or with high percetage of missing data.

## If the filter is not enabled, it will skip this step

print_header("Step 4 - Filtering alignments with iQTree information");

my %alnfil_dirs = ();
my %outgroup_ids = ();

## First, create a directory for the guidance outputs
my $dir04_alnfil = File::Spec->catfile($outdir, "04_AlignmentFiltered");
my $log04_alnfil = File::Spec->catfile($outdir, "run04_alignment_filtering.log");

if (-d $dir04_alnfil) {

    opendir( my $dir04_fh, $dir04_alnfil);
    while(readdir $dir04_fh) {

        my $subdir04 = File::Spec->catfile($dir04_alnfil, $_);
        my $subdir04_abs = File::Spec->rel2abs($subdir04);
        if ($_ =~ m/(.+).aln_filtered.phy/) {

            my $gid = $1;
            $alnfil_dirs{$gid} = $subdir04_abs;
        }
    }
    closedir($dir04_fh);

    print STDERR "\tAlignment filtering directory detected.\n";
    my $alnf_files_n = scalar(keys %alnfil_dirs);

    if ($alnf_files_n > 0) {

        print STDERR "\t$alnf_files_n files have been added to the pipeline.\n";
    }
    else {

        die("\nERROR: No filtered alignment files were detected inside $dir04_alnfil.\n\tPlease delete the directory and rerun the script.\n");
    }
}
else {

    mkdir($dir04_alnfil);
}

if (scalar(keys %alnfil_dirs > 0)) {

    print STDERR "\n\tFiltered alignment files were detected. Skipping step.\n";

}
else {

    open my $alnf_log_fh, '>', $log04_alnfil;

    my ($rem_taxa, $rem_align) = (0, 0);
    ## Now it will go file by file and checke several iQtree alignment options

    foreach my $gid (sort keys %testtax_iqtreem) {

        my %iqtree_taxacheck = %{$testtax_iqtreem{$gid}}; 
        my $align_file = "MSA.MAFFT.aln.With_Names";
        if ($opt_G) {

            $align_file = "MSA.MAFFT.Without_low_SP_Col.With_Names";
        }

        my $target_file = File::Spec->catfile($guidance_dirs{$gid}, $align_file);
        my $out_file = File::Spec->catfile($dir04_alnfil, $gid .".aln_filtered.phy");
   
        my $old_align_obj = Bio::AlignIO->new(-file   => $target_file,
                                              -format => 'fasta');

        my $remove_alignment = 0;

	print $alnf_log_fh "PROCESSING $target_file\n";

        while ( my $aln = $old_align_obj->next_aln() ) {

            my %taxa_count = ();
            foreach my $seqobj ($aln->each_seq) {

	        my $id = $seqobj->id();
                my @iddex = split(//, $id);
		my $length_t = 4;
                if ($outgroup_taxa =~ m/.+/) {
                    $length_t = length($outgroup_taxa) - 1;
                }
                my $taxa = join("", @iddex[0..$length_t]);

                ## Add outgroup ids
                if ($outgroup_taxa =~ m/\w+/) {
                    if ($taxa eq $outgroup_taxa) {

                        if (exists $outgroup_ids{$gid}) {
                        
                            push(@{$outgroup_ids{$gid}}, $id);
                        }
                        else {

                            $outgroup_ids{$gid} = [$id];
                        }
                    }
                }
                
                unless (exists $taxa_count{$taxa}) {

                    $taxa_count{$taxa} = 0;
                }
                my $taxa_check = $iqtree_taxacheck{$id}->{"test_result"};

                if ($taxa_check eq "failed" && $opt_F)  {

                    $aln->remove_seq($seqobj);
		    print $alnf_log_fh "\tTAXA $id has been removed\n";
                    $rem_taxa++;
                }
                else {

                    $taxa_count{$taxa}++;
                }                
            }

            ## Now it will check zero taxa or missing outgroup

            if ($outgroup_taxa =~ m/\w+/) {
                unless (exists $taxa_count{$outgroup_taxa}) {
                
                    print STDERR "\n\tWARNING: $outgroup_taxa does not exist in the dataset $gid. Please check.\n";
                }
                else {
                    if ($taxa_count{$outgroup_taxa} == 0) {

                        $remove_alignment = 1;
                        print $alnf_log_fh "\tALIGNMENT was removed because does not have the outgroup taxa: $outgroup_taxa\n";
                    }
                }
            }

            ## Check the number of taxa with zero representatives
            my $taxa_n = scalar(keys %taxa_count);
            my $zero_taxa_n = 0;
            foreach my $tx (sort keys %taxa_count) {

                if ($taxa_count{$tx} == 0) {
 
                    $zero_taxa_n++;
                }
            }

            ## How many zero taxa will be adequate
            my $missing_ratio = $zero_taxa_n/$taxa_n;
            if ($missing_ratio > $filter_missing_taxa) {  

                $remove_alignment = 1;
                print $alnf_log_fh "\tALIGNMENT was removed. The ratio of missing taxa ($missing_ratio) is higher than the cutoff ($filter_missing_taxa)\n";
            }

            if ($remove_alignment == 0) {

                my $new_align_obj = Bio::AlignIO->new(-file   => ">$out_file" ,
                                                      -format => 'phylip');
                $new_align_obj->write_aln($aln);
            }
            else {

                $rem_align++;
            }
         }

        if ($remove_alignment == 0) {
            $alnfil_dirs{$gid} = $out_file;
        }
    }

    my $alnfil_n = scalar(keys %alnfil_dirs);
    print STDERR "\n\t$alnfil_n alignment files remain after filtering.\n";
    print STDERR "\t$rem_taxa taxa have been removed.\n";
    print STDERR "\t$rem_align alignments have been removed.\n";
}

#########################################################
## STEP 5: RUN IQTREE WITH BOOTSTRAPS                  ##
#########################################################

## Once Guidance runs, the script will select the alignment
## files and run iqTree

print_header("Step 5 - Run iQtrees - Boostraps");

my %iqtreeb_dirs = ();

## First, create a directory for the guidance outputs
my $dir05_iqtreeb = File::Spec->catfile($outdir, "05_iQtreeBoots");
my $log05_iqtreeb = File::Spec->catfile($outdir, "run05_iQtreeBoots.log");

if (-d $dir05_iqtreeb) {

    opendir( my $dir05_fh, $dir05_iqtreeb);
    while(readdir $dir05_fh) {

        my $subdir05 = File::Spec->catfile($dir05_iqtreeb, $_);
        my $subdir05_abs = File::Spec->rel2abs($subdir05);
        if ($_ =~ m/(.+)_iQtreeBoots/) {

            my $gid = $1;
            my $clid_iqtreeb_pre = File::Spec->catfile($subdir05_abs, $gid . "_iqtree_bootstraps");
            $iqtreeb_dirs{$gid} = $clid_iqtreeb_pre;
        }
    }
    closedir($dir05_fh);

    print STDERR "\tiQtree boostrap directory detected.\n";
    my $iqtreeb_files_n = scalar(keys %iqtreeb_dirs);

    if ($iqtreeb_files_n > 0) {

        print STDERR "\t$iqtreeb_files_n files have been added to the pipeline.\n";
    }
    else {

        die("\nERROR: No iQTree files were detected inside $dir05_iqtreeb.\n\tPlease delete the directory and rerun the script.\n");
    }
}
else {

    mkdir($dir05_iqtreeb);
}

if (scalar(keys %iqtreeb_dirs > 0)) {

    print STDERR "\n\tiQtree models files were detected. Skipping step.\n";

}
else {

    my $dir05_iqtreeb_abs = File::Spec->rel2abs($dir05_iqtreeb);

    open my $iqtreeb_log_fh, '>', $log05_iqtreeb;

    my ($iqtreeb_runs, $iqtreeb_ok, $iqtreeb_fails) = (0, 0, 0);

    foreach my $gid (sort keys %alnfil_dirs) {

        my $clid_iqtreeb_out = File::Spec->catfile($dir05_iqtreeb_abs, $gid . "_iQtreeBootstrap");
        mkdir($clid_iqtreeb_out);
        my $clid_iqtreeb_pre = File::Spec->catfile($clid_iqtreeb_out, $gid . "_iqtree_bootstraps");

        my @iqtreeb_cmd = ($exepath{'iqtree'}, "-s", $alnfil_dirs{$gid}, "-pre", $clid_iqtreeb_pre);
        push(@iqtreeb_cmd, ("-nt", $threads));

        ## It will run these steps with the following defaults
        my %iqtreeb_defaults = (
            "-m"     => $parsed_iqtreem{$gid},
            "-bb"    => 1000,
            "-bnni"  => "",
            "-alrt"  => 1000, 
            "-redo"  => "",
        );

        if (exists $outgroup_ids{$gid}) {

            ## Only one outgroup can be used
            my @outgroups = @{$outgroup_ids{$gid}};
            $iqtreeb_defaults{"-o"} = $outgroups[0];
        }

        my %iqtreeb_args = %iqtree_args;
        foreach my $def_arg (sort keys %iqtreeb_defaults) {

            unless (exists $iqtreeb_args{$def_arg}) {

                $iqtreeb_args{$def_arg} = $iqtreeb_defaults{$def_arg};
            }
        }

        foreach my $iqtree_arg (sort keys %iqtreeb_args) {

            push @iqtreeb_cmd, $iqtree_arg;
            if ($iqtreeb_args{$iqtree_arg} =~ m/.+/) {

                push @iqtreeb_cmd, $iqtreeb_args{$iqtree_arg};
            }
        }

        print $iqtreeb_log_fh "RUN\tIQTREE (BOOSTRAP)\t$gid\tSTART\n";
        my $iqtreeb_cmd = join(" ", @iqtreeb_cmd);
        print $iqtreeb_log_fh "CMD $iqtreeb_cmd\n";

        $iqtreeb_runs++;
        my @iqtreeb05run = run( command => \@iqtreeb_cmd, verbose => $opt_V );
        if ($iqtreeb05run[1]) {

            print $iqtreeb_log_fh "RUN\tIQTREE (BOOSTRAP)\t$gid\tFAIL\n";
            print $iqtreeb_log_fh "IQTREE ERROR: $iqtreeb05run[1]\n";
            foreach my $err (@{$iqtreeb05run[4]}) {

                print $iqtreeb_log_fh "ERROR BACKTRACE: $err\n";
            }
            print $iqtreeb_log_fh "\n";
            $iqtreeb_fails++;
        }
        else {

          print $iqtreeb_log_fh "RUN\tIQTREE (BOOSTRAP)\t$gid\tFINISHED\n";
            print $iqtreeb_log_fh "IQTREE (BOOTSTRAP) EXECUTION MESSAGE: $iqtreeb05run[0]\n\n";
            $iqtreeb_dirs{$gid} = $clid_iqtreeb_pre;
            $iqtreeb_ok++;
        }
    }

    print STDERR "\tiQtree (boostrap) runs finished\n";
    print STDERR "\t\t$iqtreeb_runs processes have been run of which $iqtreeb_fails failed and $iqtreeb_ok succeed\n";
}


$date = `date`;
chomp($date);
print STDERR "\n\n############################################################";
print STDERR "\n## FromAlign2Trees Ends ($date)     ##\n";
print STDERR "############################################################\n\n";



=head2 help

  Usage: help()
  Desc: print help of this script
  Ret: none
  Args: none
  Side_Effects: exit of the script
  Example: if (!@ARGV) {
               help();
           }

=cut

sub help {
  print STDERR <<EOF;
  $0:

    Description:


    Usage:
      
       FromAlign2Trees [-h] -i <fasta_file_list> -d <output_dir> -t <threads>
                      [-g <guidance_conf>] [-q <iqtree_conf>] [-o <outgroup_taxon>]
                      [-V] [-v]
      
    Flags:

      -i <fasta_file_list>      File with two fields: CLID and fasta file path (mandatory)
      -d <output_dir>           Name of the output directory (mandatory)
      -t <threads>              Number of threads to be used by the Guidance and iQtree (default 2)
      -g <guidance_conf>        Guidance configuration file (optional)
      -q <iqtree_conf>          iQtree configuration file (optional)
      -o <outgroup_taxon>       outgroup taxon (optional)
      -V <be_verbose>           print more details of the running scripts
      -v <version>              print script version
      -h <help>                 Print the help

EOF
exit (1);
}

=head2 print_header

  Usage: print_head("Message");
  Desc: print a section head
  Ret: None
  Args: Message to print in the header
  Side_Effects: None
  Example: print_head("Step1: This is a test");

=cut


sub print_header {
    my $message = shift;

    my $date = `date`;
    chomp($date);

    print STDERR "\n";
    print STDERR "============================================================";
    print STDERR "\n $message ($date)\n";
    print STDERR "============================================================";
    print STDERR "\n\n";
}


=head2 parse_iqtree_file

  Usage: my $iqtree_info_hashref = parse_iqtree_file($file)
  Desc: Function to parse the iqtree_file
  Ret: A hash ref. with keys=iqtree_parameter, value=iqtree_value
  Args: $file, filename with iqtree data
  Side_Effects: die fi somethings goes wrong
  Example: my $iqtree_log_href = parse_iqtree_file($file)

=cut

sub parse_iqtree_file {

    my $file = shift();
   
    my %iqtree_ps = ();
    open my $fh, '<', $file;
    while(<$fh>) {

        chomp($_);
        if ($_ =~ m/Input\s+data:\s+(\d+)\s+sequences\s+with\s+(\d+)\s+codon\s+sites/) {

            $iqtree_ps{"SeqN"} = $1;
            $iqtree_ps{"CodonSites"} = $2;
        }
        elsif ($_ =~ m/Number\s+of\s+constant\s+sites:\s+(\d+)\s+\(=\s+(.+)%\s+of\s+all\s+sites\)/) {

            $iqtree_ps{"ConstantSites"} = $1;
            $iqtree_ps{"ConstantSitesPerc"} = $2;
        }
	elsif ($_ =~ m/Number\s+of\s+invariant\s+\(constant\s+or\s+ambiguous\s+constant\)\s+sites:\s+(\d+)\s+\(=\s+(.+)%\s+of\s+all\s+sites\)/) {

            $iqtree_ps{"InvariantSites"} = $1;
            $iqtree_ps{"InvariantSitesPerc"} = $2;
        }
        elsif ($_ =~ m/Number\s+of\s+parsimony\s+informative\s+sites:\s+(\d+)/) {

            $iqtree_ps{"ParsimonySites"} = $1;
	}
        elsif ($_ =~ m/Number\s+of\s+distinct\s+site\s+patterns:\s+(\d+)/) {

            $iqtree_ps{"DistinctSitePatterns"} = $1;
        }
        elsif ($_ =~ m/Best-fit\s+model\s+according\s+to\s+BIC:\s+(.+)/) {

            $iqtree_ps{"BestFitModel"} = $1;
        }
    }

    return \%iqtree_ps;
}


=head2 parse_iqtree_log

  Usage: my $iqtree_log_hashref = parse_iqtree_log($file)
  Desc: Function to parse the iqtree log file
  Ret: A hash ref. with keys=iqtree_parameter, value=iqtree_value
  Args: $file, filename with iqtree data
  Side_Effects: die fi somethings goes wrong
  Example: my $iqtree_log_href = parse_iqtree_log($file)

=cut

sub parse_iqtree_log {

    my $file = shift();

    my %iqtree_ls = ();
    my $parse_on = 0;
    open my $fh, '<', $file;
    while(<$fh>) {

        chomp($_);
        if ($_ =~ m/\s+Gap\/Ambiguity\s+Composition\s+p-value/) {

            $parse_on = 1;
        }
        else {
            if ($parse_on == 1) {

                if ($_ =~ m/\s+(\d+)\s+(.+?)\s+(.+?)%\s+(\w+)\s+(.+)%/) {

                    my $taxaid = $2;
                    $iqtree_ls{$taxaid} = {
                        "taxa_order"   => $1,
                        "taxa_id"      => $2,
                        "gap_amb_perc" => $3,
                        "test_result"  => $4,
                        "p_value"      => $5
                    }
                }
                else {

                    $parse_on = 0;
                }
            }
        } 
    }
    return(\%iqtree_ls);
}




####
1; #
####


